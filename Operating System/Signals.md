# Signals

> Signals are a convenient way to deliver low-priority information and for users to interact with their programs when other ways don't work (for example standard input being frozen). 
>
> They allow a program to clean up or perform an action in the case of an event.
> 
> For those of you with an architecture background, the interrupts used here aren't the interrupts generated by the hardware. Those interrupts are almost always handled by the kernel because they require higher levels of privileges. Instead, we are talking about software interrupts that are generated by the kernel - though they can be in response to a hardware event like `SIGSEGV`.

A signal allows one process to asynchronously send an event or message to another process. 

If that process wants to accept the signal, it can, and then, for most signals, decide what to do with that signal.

A **signal disposition** is a per-process attribute that determines how a signal is handled after it is delivered. Think of it as a table of signal-action pairs:
1. `TERM`, terminates the process
2. `IGN`, ignore
3. `CORE`, generate a core dump
4. `STOP`, stops a process
5. `CONT`, continues a process
6. Execute a custom function.


| Name | Portable Number | Default Action | Usual Use |
|---|---|---|---|
| `SIGINT`  | 2   | Terminate (Can be caught)       | Stop a process nicely
| `SIGQUIT` | 3   | Terminate (Can be caught)       | Stop a process harshly
| `SIGTERM` | 15  | Terminate Process               | Stop a process even more harshly
| `SIGSTOP` | N/A | Stop Process (Cannot be caught) | Suspends a process
| `SIGCONT` | N/A | Continues a process             | Starts after a stop
| `SIGKILL` | 9   | Terminate Process (Cannot be caught) | You want the process gone

> `kill -9` (`SIGKILL`) is not recommended to use in most cases.
> The reason is that the process would have no chance to:
> 1) shut down socket connections
> 2) clean up temp files
> 3) inform its children that it is going away
> 4) reset its terminal characteristics
> and so on.
>
> Therefore, if we want to terminate a process:
> 1. send 15 `SIGTERM`
> 2. if not work, send 2 `SIGINT`
> 3. if still not work, send 1
> 4. if still not work, the program is badly behaved! Don't use `kill -9`!

## Signal Process

The overall process for how a kernel sends a signal are below:
1. If no signals have arrived, the process can install its own signal handlers. This tells the kernel that when the process gets signal X that it should jump to function Y.
2. A signal that is created is in a **generated** state.
3. The time between when a signal is *generated* and the kernel can apply the mask rules is called the **pending** state.
4. Then the kernel then checks the process' *signal mask*. If the mask says all the threads in a process are blocking the signal, then the signal is currently **blocked** and nothing happens until a thread unblocks it.
   - A **signal mask** determines whether a particular signal is delivered or not. 
5. If a single thread can accept the signal, then the kernel executes the action in the disposition table. If the action is a default action, then no threads need to be paused.
6. Otherwise, the kernel delivers the signal by stopping *whatever* a particular thread is doing currently, and jumps that thread to the *signal handler*. The signal is now in the **delivered** phase. 
   - More signals can be generated now, but they can't be delivered until the signal handler is complete which is when the delivered phase is over.
7. Finally, we consider a signal **caught** if the process remains intact after the signal was delivered.

As a flow chart:
![](https://raw.githubusercontent.com/Hangary/CS-Study-Notes/main/images/20201127215824.png)


## Sending Signals

Signals can be generated in multiple ways:
1. The *user* can send a signal. 
   - For example, you are at the terminal, and you press `CTRL-C`. 
   - One can also use the built-in `kill` or `killall` to send any signal.
     - `kill -<signal> <pid>` would send the signal to the process. For example, `kill -SIGSTOP 403`.
     - `killall <process_name>` can be used to kill a process by its name, instead of pid.
2. The *system* can send an event. 
   - For example, if a process accesses a page that it isn't supposed to, the hardware generates an interrupt which gets intercepted by the kernel. The kernel finds the process that caused this and sends a software interrupt signal `SIGSEGV`. There are other kernel events like a child being created or a process needs to be resumed.
3. Finally, another *process* can send a message.
   - System calls `raise(signal)` and `kill(pid, signal)` are used to send signals. `raise` would send itself a signal.
   - For non-root processes, ==signals can only be sent to processes of the same user==. You can't SIGKILL any process!
   - This could be used in low-stakes communication of events between processes. However, if you are relying on signals to be the driver in your program, you should rethink your application design. There are many drawbacks to using POSIX/Real-Time signals for asynchronous communication. The best way to handle interprocess communication is to use, well, interprocess communication methods specifically designed for your task at hand.

## Handling Signals

There are strict limitations on the executable code inside a signal handler. 

Most library and system calls are `async-signal-unsafe`, meaning they may not be used inside a signal handler because they are not ***re-entrant***. 

**Re-entrant safety** means that your function can be frozen at any point and executed again.

A safe way to avoid undefined behaviors caused by unsafe functions in a signal handler is to:
1. set a variable and let the program resume operating.
2. when the program see the variable, it would do corresponding things.

The design pattern also helps us in designing programs that can receive signals twice and operate correctly.

One thing to note: to avoid the variable to be optimized or cached, we need to specify it as `volatile` and `atomic`:
```C
volatile sig_atomic_t pleaseStop;
```

Here,
- `volatile`: not optimize or cache this value
- `sig_atomic_t`: read or write of this value would be atomic

### Sigaction

You should use `sigaction` instead of `signal` because it has better defined semantics. 
- `signal` on different operating system does different things which is **bad**. 
- `sigaction` is more portable and is better defined for threads. 

You can use system call `sigaction` to set the current handler and disposition for a signal or read the current signal handler for a particular signal.
```C
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

The sigaction struct includes two callback functions (we will only look at the 'handler' version), a signal mask and a flags field:
```C
struct sigaction {
  void     (*sa_handler)(int);
  void     (*sa_sigaction)(int, siginfo_t *, void *);
  sigset_t   sa_mask;
  int        sa_flags;
};
```

Suppose you stumble upon legacy code that uses `signal`. The following snippet installs `myhandler` as the SIGALRM handler.

```C
signal(SIGALRM, myhandler);

// The equivalent `sigaction` code is:

struct sigaction sa;
sa.sa_handler = myhandler;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;
sigaction(SIGALRM, &sa, NULL)
```

However, we typically may also set the mask and the flags field. The mask is a temporary signal mask used during the signal handler execution. If the thread serving the signal is interrupted in the middle of a system call, the `SA_RESTART` flag will automatically restart some system calls that otherwise would have returned early with `EINTR` error. The latter means we can simplify the rest of code somewhat because a restart loop may no longer be required.

```C
sigfillset(&sa.sa_mask);
sa.sa_flags = SA_RESTART; /* Restart functions if interrupted by handler */
```

It is often better to have your code check for the error and restart itself due to the selective nature of the flag.

## Blocking Signals


## Signals in Child Processes and Threads

After forking, the child process inherits a copy of the parent's signal dispositions and a copy of the parent's signal mask. 
- If you have installed a `SIGINT` handler before forking, then the child process will also call the handler if a `SIGINT` is delivered to the child. 
- If `SIGINT` is blocked in the parent, it will be blocked in the child as well. 
- Note that pending signals for the child are not inherited during forking. 
- After `exec` though, only the signal mask and pending signals are carried over. Signal handlers are reset to their original action, because the original handler code may have disappeared along with the old process.